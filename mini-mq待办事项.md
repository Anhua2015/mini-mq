# Mini-mq待办事项





1.  实现Prefetch及其流控（√）



2.  Ack的失败重试机制（√）



3.  消费组ConsumerGroup的实现（√）



4.  补充实现所有handler（包括idGenerator的整合）（√）



5.  客户端本地存储实现（预计使用内存保存已成功记录，并定期发送至broker进行对账，成功后移除记录，避免空间无限制扩大占用，但无法解决客户端宕机下重复消费的情况）（√）



6.  “对账”功能的实现（√）



7.  实现注册中心，支持集群（√）



8.  完成core模块的最后整合和测试（√）



9.  完成client模块的最后整合和测试（√）



10. 整体整合和测试（√）

   1). 消息生产发送和自动批量确认（√）

   2). 消息接收消费和消息确认、拒绝消费（√）

   3). 对账（√）

   4). 流控（√）

   5). 集群（√）



11. 编写示例Demo

    一、生产者能力和消费者能力相同，且较弱

    生产者定时每秒发送一条消息，消费者定时每秒消费并确认一条消息

    ​	1.1)    对于同一消息主题，单个生产者和单个消费者。

    ​	1.2)    对于同一消息主题，多个生产者和单个消费者。

    ​	1.3)    对于同一消息主题，多个生产者和多个消费者（同一消费组）。

    ​	1.4)    对于同一消费主题，多个生产者和多个消费者（不同消费组）。

    ​	2.2) 对于多个消费主题，每个消费主题存在两个生产者和两个消费组（每个消费组存在两个消费者）。

    ​Demo1：多个生产者(p1,p2,p3)和一个消费者，订阅同一主题。

    Demo2：多个生产者(p1,p2,p3)和多个消费者(g1-c1,g1-c2,g2-c1)，(g1-c1,g1-c2属于消费组g1，g2-c1属于消费组g2)。

    Demo3：多个生产者(t1-p1,t1-p2,t2-p1,t2-p2)，(t1-p1,t1-p2订阅消息主题t1，t2-p1,t2-p2订阅消息主题t2)，多个消费者(t1-g1-c1,t1-g1-c2,t2-g2-c1,t2-g2-c2)，(t1-g1-c1,t1-g1-c2订阅同一消费主题t1，且属于同一消费组g1)，(t2-g2-c1,t2-g2-c2订阅同一消费主题t2，且属于同一消费组t2)



​	二、生产者能力和消费者能力相同，且较强

​	生产者定时每1秒发送1w条消息，消费者定时每秒消费并确认1w条消息

 

​	三、生产者能力和消费者能力不同，生产者能力较强，消费者能力较弱

​	生产者定时每0.5秒发送1条消息，消费者定时每2秒消费并确认1条消息

 

​	四、生产者能力和消费者能力不同，生产者能力较弱，消费组能力较强

​	生产者定时每2秒发送1条消息，消费者定时每0.5秒消费并确认1条消息

 

12. 进一步完善文档，进一步完善底层原理图



13. 性能测试

    1) 10000->20000->50000->100000->200000->500000->1000000->找到性能瓶颈->定位系统瓶颈->分析优化点

    2) 计算统计不同压力下的系统吞吐量



14. 完成文档终稿







BUG&优化点

1. prePull的时机（1.消费者preFetch操作时 2.此时内存中存在该topic和该消费组 3.该消费组目前存在订阅者 4.当前消费组中的该topic中的消息数量少于2*num(请求数量)）


2. prePull有时触发有时不触发（已解决，原因：netty Bytebuf在解码的过程中未清空已读缓冲区）

3.  sendMessage到partition的分发机制（目前的机制：如果消息存在key，则分发到key hash后的partition，如果消息不存在key，则随机分发到某个partition）
4.  从partition取消息getMessage的路由规则（目前的机制：如果指定取某个key的消息，则根据key路由到partition，且仅消费该partition，如果未指定key，则轮询从partition获取消息，如果一次轮询未获得消息则返回空）
5.  Client端的流控如何设计：1.快速失败 2.超时等待 3.提供缓冲区，超出警告，并暂时拒绝所有消息，直到缓冲区清空，需要考虑如何回调及线程安全的问题。

（最终选择类似于第三种方案，当pending中的消息量达到阈值，直接拒绝，返回发送失败，当消息发送时，首先进入pending队列，然后在某种条件下触发batchSend操作（条件1.此时没有正在进行的batchSend操作，当通过条件表示此时触发了batchSend操作，当从pending队列中取消息后则认为batchSend操作结束，即无需等到操作发送或回调，这样的话，理论上控制的消息流量计算公式为：最大pending阈值\*2，因为在发送第一批pending量时当前发送消息量为pending阈值，而此时的队列必定小于阈值，如果此时依然有消息被发送，则会阻塞到pending上等待下一次batchSend，那么理论上会有2\*pending阈值的消息阻塞在内存中，发送时检测pending的消息大于或等于pending阈值时会被直接拒绝）

6. 当强制关闭消费者时，会令prefetch且未确认消费的消息废弃（无法再被自动消费）：在下个版本增加本地持久化存储功能
7. 提供admin功能，允许通过控制台命令控制，允许远程连接控制
8. broker引导程序，让程序的启动和关闭更优雅